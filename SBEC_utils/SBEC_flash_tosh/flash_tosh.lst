C:\Users\Adam\Desktop\jeep_2.5L\SBEC_utils\SBEC_flash_tosh\flash_tosh.lst - generated by MGTEK Assembler ASM11 V1.26 Build 144 for WIN32 (x86) - Wed Dec 29 14:21:37 2021

    1:                                 ; 68HC11 bootstrap, download to a SBEC that has been
    2:                                 ; placed into bootstrap mode by applying 12 volts to
    3:                                 ; pin 45 until SBEC sends 0x00 on pin 25.
    4:                                 
    5:          =00000000                  ORG $0000
    6:                                 
    7:     0000                        THE_BEGIN:
    8:     0000                        Start:
    9:     0000 8E 00FF                    ldS     #$FF        ; stack pointer = 0xFF
   10:     0003 CE 1000                    ldX     #$1000      ; config 68HC11 registers
   11:     0006 CC 330C                    ldD     #$330C      ; config SCI
   12:     0009 A7 2B                      staA    $2B,X       ; store value in register A ($33) in 0x1000 + 0x002B
   13:                                                         ; configures SCI for 1200 BAUD
   14:     000B E7 2D                      staB    $2D,X       ; store value in register B ($0C) in 0x1000 + 0x002D
   15:                                                         ; configures SCI for TXD/RXD
   16:     000D 0F                         sei                 ; disable interrupts
   17:     000E CC 6001                    ldD     #$6001      ; load D register with 0x6001
   18:     0011 A7 3C                      staA    $3C,X       ; store value in register A ($60) in 0x1000 + 0x003C
   19:                                                         ; enables Special Mode
   20:     0013 E7 3F                      staB    $3F,X       ; store value in register B ($01) in 0x1000 + 0x003F
   21:                                                         ; System Config Register
   22:                                 
   23:                                 ; give receiver around 100ms
   24:                                 
   25:     0015 CE 7E00                    ldX     #$7E00
   26:     0018                        Delay:
   27:     0018 09                         deX
   28:     0019 26 FD                      bne     Delay
   29:                                 
   30:     001B CE 8000                    ldx   #$8000               ; load index with value
   31:                                 
   32:     001E                        Next64ByteBlock:
   33:     001E 18CE 0085                         ldy   #Buffer               ; load index with value
   34:                                 
   35:     0022                        LoopToFillRAM:
   36:     0022 FC 102E                           ldd   $102E
   37:     0025 85 20                             bita  #%00100000                       ;  -00100000-
   38:     0027 27 F9                             beq   LoopToFillRAM              ; branch if equal (zero)
   39:     0029 18E7 00                           stab  $00,Y                    ;  -00000000-
   40:     002C 1808                              iny                              ; increment index (x=x+1)
   41:     002E 188C 00C5                         cpy   #LenBuffer
   42:     0032 26 EE                             bne   LoopToFillRAM              ; branch if not equal (not zero)
   43:     0034 C6 C8                             ldab  #$C8                      ; load b with value -11001000-
   44:     0036 9D 7F                             jsr   ShortDelayLoop
   45:     0038 18CE 0085                         ldy   #Buffer               ; load index with value
   46:                                 
   47:     003C                        InitRetryCounter:
   48:     003C C6 19                             ldab  #$19                       ; load b with value -00011001-
   49:     003E D7 84                             stab  RetryCounter               ; store b into memory
   50:                                 
   51:     0040                        ProgramBytes:
   52:     0040 CC AAA0                           ldD   #$AAA0                    ; load d (a&b) with value
   53:     0043 B7 D555                           staA  $D555
   54:     0046 43                                comA
   55:     0047 B7 AAAA                           staA  $AAAA
   56:     004A B7 D555                           staA  $D555                      ; store b into memory
   57:     004D 5F                                clrB                             ; b = 0
   58:     004E F7 A000                           staB  $A000                      ; store b into memory
   59:     0051 18E6 00                           ldaB  $00,Y                    ; load b with memory at index + value -00000000-
   60:     0054 E7 00                             staB  $00,X                    ;  -00000000-
   61:     0056 C6 50                             ldaB  #$50                      ; load b with value -01010000-
   62:     0058 20 25                             bra   ShortDelayLoop             ; branch
   63:                                 ; not sure what all this is about, but it's different from the FCC version. Needed?
   64:                                 ;           ldab  0x00, Y                   ; load b with memory at index + value -00000000-
   65:                                 ;           stab  0x00, X                   ;  -00000000-
   66:                                 ;           nop                             ; no operation
   67:                                 ;           nop                             ; no operation
   68:                                 
   69:     005A                        VerifyByte:
   70:     005A A6 00                             ldaA  $00,X                    ; load b with memory at index + value -00000000-
   71:                                 ;           ldaa  LAAAA                     ; load a with memory contents
   72:                                 ;           ldaa  LD555                     ; load a with memory contents
   73:                                 ;           ldaa  CPU_SerialStatus          ; load a with memory contents
   74:                                 ;           ldaa  CPU_SerialData            ; load a with memory contents
   75:     005C 18A1 00                           cmpa  $00,Y                    ;  -00000000-
   76:     005F 27 06                             beq   ByteVerified               ; branch if equal (zero)
   77:     0061                        VerifyFailed:
   78:     0061 7A 0084                           dec   RetryCounter               ; decrement memory contents
   79:     0064 26 DA                             bne   ProgramBytes               ; branch if not equal (not zero)
   80:                                 
   81:     0066                        Finished:
   82:                                 
   83:     0066 CF                               stop
   84:                                 
   85:     0067                        ByteVerified:
   86:     0067 08                                inX                              ; increment index (x=x+1)
   87:     0068 1808                              inY                              ; increment index (x=x+1)
   88:     006A 188C 00C5                         cpY   #LenBuffer
   89:     006E 26 CC                             bne   InitRetryCounter           ; branch if not equal (not zero)
   90:                                 
   91:     0070                        SkipEEPROM:
   92:     0070 8C B600                           cpX   #$b600
   93:     0073 26 03                             bne   Skip                       ; branch if not equal (not zero)
   94:     0075 CE B800                           ldX   #$b800                    ; load index with value
   95:                                 
   96:     0078                        Skip:   
   97:     0078 8C 0000                           cpX   #$0000
   98:     007B 26 A1                             bne   Next64ByteBlock
   99:     007D 20 E7                             bra   Finished                   ; branch if not equal (not zero)
  100:                                 
  101:     007F                        ShortDelayLoop:
  102:     007F 5A                                decB
  103:     0080 26 FD                             bne   ShortDelayLoop             ; branch if not equal (not zero)
  104:     0082 39                                rts                              ; return from subroutine
  105:     0083                        Done:
  106:     0083 CF                         stop
  107:                                 
  108:     0084                        RetryCounter:
  109:     0084 19                         fcb   $19
  110:     0085                        Buffer:
  111:                                  REPEAT $40
  112:                                     fcb 0x00
  113:                                  ENDR
  114:     00C5                        LenBuffer:
  115:     00C5                        THE_END:
  116:                                 
  117:                                                              ; pad bootstrap to 256 total bytes
  118:                                  REPEAT 256-(THE_END-THE_BEGIN)
  119:                                     fcb 0x00
  120:                                  ENDR

Symbols:
buffer                          *00000085
byteverified                    *00000067
delay                           *00000018
finished                        *00000066
initretrycounter                *0000003c
lenbuffer                       *000000c5
looptofillram                   *00000022
next64byteblock                 *0000001e
programbytes                    *00000040
retrycounter                    *00000084
shortdelayloop                  *0000007f
skip                            *00000078
the_begin                       *00000000
the_end                         *000000c5

